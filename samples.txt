THIS FILE JUST HAS EXAMPLES OF HOW TO DECLARE / INSTANTIATE / CALL THINGS



*-*-*-*-*-*-*
*   ARRAYS  *
*-*-*-*-*-*-*

  EMPTY, DATA TYPE CANNOT BE INFERRED - requires () parens
    var arrayName[dataType]()
    var arrayName[String]();


  PREFILLED
    var arrayName[“value”, “value”, “value”]


*-*-*-*-*-*-*
*  CASTING  *
*-*-*-*-*-*-*

  Values are NEVER IMPLICITLY CONVERTED between types
  Use either of the two typical forms:

  (targetType)value

  targetType(value)


*-*-*-*-*-*-*
* CONSTANTS *
*-*-*-*-*-*-*

  Use the keyword: let

  EXPLICIT (data type required only when value is not provided)

	let constName: dataType = value


  INFERRED (no data type required when value provided)

	let constName = “Some String”


*-*-*-*-*-*-*-*-*
* DICTIONARIES  *
*-*-*-*-*-*-*-*-*

  EMPTY, WHEN DATA TYPES CANNOT BE INFERRED - requires () parens
    var dictionaryName = [ keyDataType : valueDataType ]()
    var dictionaryName = [ String : Int ]()

  EMPTY, WHEN DATA TYPES ‘CAN’ BE INFERRED
    var dictionaryName = [ : ]

  PREFILLED:
    var dictionaryName = [
	  “keyName” : “value”,
	  “keyName” : “value”
    ]

  ADD OR EDIT A KEY / VALUE PAIR:
    dictName[“keyName”] = value

  *** When you print a value, such as a dictionary of [String : Int]
      the value is IMPLICITLY COERCED TO ‘Any’ (Int?)
      You have 3 options to resolve this:
	 1.) Force unwrap with an exclamation ! :  print(dictName[“key”]!)			// 3
	 2.) Provide a default value with ??    :  print(dictName[“key”] ?? defaultValue)	// 3
	 3.) Explicitly cast ‘as Any’	     :  print(dictName[“key”] as Any)		// Optional(3)


*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*  INSERT VALUES INTO STRINGS *
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

  \(varName)
  \(constName)
  \(some + kind + of + expression)


*-*-*-*-*-*-*
* VARIABLES *
*-*-*-*-*-*-*

  Use the keyword: var

  EXPLICIT (data type required only when value is not provided)

	var varName: dataType = value


  INFERRED (no data type required when value provided)

	var varName = 7