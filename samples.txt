THIS FILE JUST HAS EXAMPLES OF HOW TO DECLARE / INSTANTIATE / CALL THINGS



*-*-*-*-*-*-*
*   ARRAYS  *
*-*-*-*-*-*-*

  EMPTY, DATA TYPE CANNOT BE INFERRED - requires () parens
    var arrayName[dataType]()
    var arrayName[String]();


  PREFILLED
    var arrayName[“value”, “value”, “value”]


*-*-*-*-*-*-*
*  CASTING  *
*-*-*-*-*-*-*

  Values are NEVER IMPLICITLY CONVERTED between types
  Use either of the two typical forms:

  (targetType)value

  targetType(value)


*-*-*-*-*-*-*
* CONSTANTS *
*-*-*-*-*-*-*

  Use the keyword: let

  EXPLICIT (data type required only when value is not provided)

	let constName: dataType = value


  INFERRED (no data type required when value provided)

	let constName = “Some String”


*-*-*-*-*-*-*-*-*
* DICTIONARIES  *
*-*-*-*-*-*-*-*-*

  EMPTY, WHEN DATA TYPES CANNOT BE INFERRED - requires () parens
    var dictionaryName = [ keyDataType : valueDataType ]()
    var dictionaryName = [ String : Int ]()

  EMPTY, WHEN DATA TYPES ‘CAN’ BE INFERRED
    var dictionaryName = [ : ]

  PREFILLED:
    var dictionaryName = [
	  “keyName” : “value”,
	  “keyName” : “value”
    ]

  ADD OR EDIT A KEY / VALUE PAIR:
    dictName[“keyName”] = value

  *** When you print a value, such as a dictionary of [String : Int]
      the value is IMPLICITLY COERCED TO ‘Any’ (Int?)
      You have 3 options to resolve this:
	 1.) Force unwrap with an exclamation ! :  print(dictName[“key”]!)			// 3
	 2.) Provide a default value with ??    :  print(dictName[“key”] ?? defaultValue)	// 3
	 3.) Explicitly cast ‘as Any’	     :  print(dictName[“key”] as Any)		// Optional(3)


*-*-*-*-*-*
* FOR-IN  *
*-*-*-*-*-*
  
  Not quite what you’re used to. Works on a collection or a specified range.
  Do not use parens to set off the conditions of the loop.

  ON COLLECTIONS:
	for item in collection { . . . }
	
	var fruitsArray = [“banana”, “apple”, “tomato”, “peach”];
	for fruit in fruits {
	  print(fruit);
	}

  ON A RANGE (NOT INCLUSIVE)
	for i in 0..<10 { . . . }   // 0 to 9

  ON A RANGE (INCLUSIVE)
	for i in 0...10 { . . . }   // 0 to 10

*-*-*-*
* IF  *
*-*-*-*

  The usual, but the condition MUST BE a boolean, and parens are optional but { braces } are NOT:

  if condition { . . . }

  if (condition) { . . . }


*-*-*-*-*-*
* IF-LET  *
*-*-*-*-*-*

  A method of testing optional values. You may also simply use   if (value != nil) { . . . }
  If the optional value is nil, it won’t be assigned to the new variable, causing the if condition to result
    to false, skipping the body:

  if let name = someOptionalVariable { . . . }

  This is the same as

  if (someOptionalVariable != nil) { . . . }


*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*  INSERT VALUES INTO STRINGS *
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

  \(varName)
  \(constName)
  \(some + kind + of + expression)


*-*-*-*-*-*-*
*   LOOPS   *
*-*-*-*-*-*-*

  See: FOR-IN
	IF
	REPEAT-WHILE
	SWITCH
	WHILE


*-*-*-*-*-*-*
* OPTIONALS *
*-*-*-*-*-*-*

  Explicit data type is required
  Place a ? after the data type
  You’ll later want to check for nil values when working with these variables.
  See IF-LET

  var varName: dataType? = value (or, = nil)
  var optionalInteger: Int? = 8
  var optionalString: String? = nil


*-*-*-*-*-*-*
* VARIABLES *
*-*-*-*-*-*-*

  Use the keyword: var

  EXPLICIT (data type required only when value is not provided)

	var varName: dataType = value


  INFERRED (no data type required when value provided)

	var varName = 7