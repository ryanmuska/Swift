THIS FILE JUST HAS EXAMPLES OF HOW TO DECLARE / INSTANTIATE / CALL THINGS



*-*-*-*-*-*-*
*   ARRAYS  *
*-*-*-*-*-*-*

  EMPTY, DATA TYPE CANNOT BE INFERRED - requires () parens
    var arrayName[dataType]()
    var arrayName[String]();


  PREFILLED
    var arrayName[“value”, “value”, “value”]



*-*-*-*-*-*-*
*  CASTING  *
*-*-*-*-*-*-*

  Values are NEVER IMPLICITLY CONVERTED between types
  Use either of the two typical forms:

	(targetType)value

	targetType(value)



*-*-*-*-*-*-*
*  CLASSES  *
*-*-*-*-*-*-*

  Use the keyword: class

    class ClassName {
      // instance variables
      // instance methods

      init(args: dataTypes) {
 	 self.varName = argName;
	 . . .
      }
    }

    var someObject = ClassName(anyRequiredArguments);

  —————————————————————————————————————————————————————————————————

  The following are examples of a class and a subclass

  —————————————————————————————————————————————————————————————————

  SIMPLE PROPERTIES

  class Shape {
    var name: String;
    var numberOfSides: Int = 0;

    func description() -> String { return “A shape named \(name).”; }

    init(name: String) { self.name = name; }
  }

  class Square : Shape {
    var sideLength: Double;

    init(name: String, sideLength: Double) {
      self.sideLength = sideLength;  // we can assign this value here
      super.init(name: name);	  // now we call the super constructor
      numberOfSides = 4;		  // now that we’ve called the super constructor, we can access ‘numberOfSides’
    }

    override func description() -> String { return “A square named \(name) with side length \(sideLength).”; }
  }

  var mySquare = Square(name: “My Square”, sideLength: 9.2);  // creates a square

  —————————————————————————————————————————————————————————————————

  COMPLEX PROPERTIES
  Complex properties require a getter/setter.
  In this example, when you GET the perimeter value, it is based off of the sideLength value.
  When you SET the sideLength value, it is again based off of the (newly provided) sideLength value.

	  class EquilateralTriangle {
	    // any desired simple properties
  	    // any desired instance methods
	    // init()
	    var perimeter: Double {
	      get { return 3.0 * sideLength; }
	      set { sideLength = newValue / 3.0; }
	    }
	  }



*-*-*-*-*-*-*
* CONSTANTS *
*-*-*-*-*-*-*

  Use the keyword: let

  EXPLICIT (data type required only when value is not provided)

	let constName: dataType = value

  —————————————————————————————————————————————————————————————————

  INFERRED (no data type required when value provided)

	let constName = “Some String”



*-*-*-*-*-*-*-*-*
* DICTIONARIES  *
*-*-*-*-*-*-*-*-*

  EMPTY, DATA TYPES CANNOT BE INFERRED - requires () parens
    var dictionaryName = [ keyDataType : valueDataType ]()
    var dictionaryName = [ String : Int ]()

  —————————————————————————————————————————————————————————————————

  PREFILLED:
    var dictionaryName = [
	  “keyName” : “value”,
	  “keyName” : “value”
    ]

    var fruitTotals = [
	“banana” : 7,
	“apple” : 3,
	“tomato” : 12
    ]

  —————————————————————————————————————————————————————————————————

  ADD OR EDIT A KEY / VALUE PAIR:
    dictName[“keyName”] = value

  —————————————————————————————————————————————————————————————————

  *** When you print a value, such as a dictionary of [String : Int]
      the value is IMPLICITLY COERCED TO ‘Any’ (Int?)
      You have 3 options to resolve this:

	 1.) Force unwrap with an exclamation ! :  print(dictName[“key”]!)			// 3
		* this is not nil-safe

	 2.) Provide a default value with ??    :  print(dictName[“key”] ?? defaultValue)	// 3
		* this is nil-safe
		* uses defaultValue provided when key-value is nil

	 3.) Explicitly cast ‘as Any’	     :  print(dictName[“key”] as Any)		// Optional(3)



*-*-*-*-*-*
* FOR-IN  *
*-*-*-*-*-*
  
  Not quite what you’re used to. Works on a collection or a specified range.
  Do not use parens to set off the conditions of the loop.

  ON COLLECTIONS:
	for item in collection { . . . }
	
	var fruitsArray = [“banana”, “apple”, “tomato”, “peach”];
	for fruit in fruits {
	  print(fruit);
	}

  —————————————————————————————————————————————————————————————————

  ON A RANGE (NOT INCLUSIVE)
	for i in 0..<10 { . . . }   // 0 to 9

  —————————————————————————————————————————————————————————————————

  ON A RANGE (INCLUSIVE)
	for i in 0...10 { . . . }   // 0 to 10



*-*-*-*-*-*-*
* FUNCTIONS *
*-*-*-*-*-*-*

  Use the keyword: func

  func functionName(paramNameOne: dataType, paramNameTwo: dataType) -> returnType { . . . }

  Within the function body, you’ll refer to the params by name.
  When calling the function, you have 3 options for how to specify the arguments, depending on how the function
    was declared.

  —————————————————————————————————————————————————————————————————

  BY NAME:
	func greet(name: String) -> String { . . . }
	greet(name: “Billy Joe”);

  —————————————————————————————————————————————————————————————————

  BY A CUSTOM LABEL:
	func greet(name person: String) -> { . . . }
	greet(person: “Billy Bob”);

  —————————————————————————————————————————————————————————————————

  WITH NO LABEL (most convenient):
	func greet(_ name: String) -> { . . . }
	greet(“Billy Bob Joe”);

  —————————————————————————————————————————————————————————————————

  *** PASSING AN ARRAY TO A FUNCTION? After the label, put the array’s data type in [brackets]:
	func doStuff(values: [Int]) -> Int { . . . }



*-*-*-*
* IF  *
*-*-*-*

  The usual, but the condition MUST BE a boolean, and parens are optional but { braces } are NOT:

  if condition { . . . }

  if (condition) { . . . }



*-*-*-*-*-*
* IF-LET  *
*-*-*-*-*-*

  A method of testing optional values. You may also simply use   if (value != nil) { . . . }
  If the optional value is nil, it won’t be assigned to the new variable, causing the if condition to result
    to false, skipping the body:

	  if let name = someOptionalVariable { . . . }

  This is the same as

	  if (someOptionalVariable != nil) { . . . }



*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*  INSERT VALUES INTO STRINGS *
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

  \(varName)
  \(constName)
  \(some + kind + of + expression)



*-*-*-*-*-*-*
*   LOOPS   *
*-*-*-*-*-*-*

  See: FOR-IN
	IF
	*REPEAT-WHILE
	*SWITCH
	*WHILE



*-*-*-*-*-*-*
* OPTIONALS *
*-*-*-*-*-*-*

  Explicit data type is required
  Place a ? after the data type
  You’ll later want to check for nil values when working with these variables.
  See IF-LET

  var varName: dataType? = value (or, = nil)
  var optionalInteger: Int? = 8
  var optionalString: String? = nil



*-*-*-*-*-*-*
*  TUPLES   *
*-*-*-*-*-*-*

  Allow you to return multiple values from a function.
  Refer to the values stored in the tuple by name OR index.
  Suppose a function that returns 3 Int values: min, max, sum:

	func returnTuple(scores: [Int]) -> (min: Int, max: Int, sum: Int) {
	  // . . .
	  // logic for assigning/computing min, max, and sum goes here
	  // . . .
	  return (min, max, sum)
	}

	var result = returnTuple(scores: myScoresArray);

	print(result.max);  // prints the max value off the tuple
	print(result[1]);   // prints the max value off the tuple



*-*-*-*-*-*-*
* VARIABLES *
*-*-*-*-*-*-*

  Use the keyword: var

  EXPLICIT (data type required only when value is not provided)

	var varName: dataType = value


  INFERRED (no data type required when value provided)

	var varName = 7